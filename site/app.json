[{"name":"app.R","content":"library(shiny)\nlibrary(bslib)\nlibrary(tinyplot)\nsource(\"calculator.R\")\n\nui <- page_navbar(\n  title = \"Powered for Paediatric Safety\",\n  nav_panel(\n    \"Information\",\n    \"Some text describing the model, inputs and calculations\"\n  ),\n  nav_panel(\n    \"Calculator\",\n    layout_columns(\n      card(\n        layout_columns(\n          card(\n            card_header(\"Reference Population\"),\n            numericInput(\"ref_cx\", \"Control rate\", value = 0.01, min = 0, max = 1, step = 0.01),\n            numericInput(\"ref_tx\", \"Treated rate\", value = 0.03, min = 0, max = 1, step = 0.01)\n          ),\n          card(\n            card_header(\"Prior Information\"),\n            numericInput(\"prior_cx_a\", \"Control alpha\", value = 1, min = 0, step = 0.5),\n            numericInput(\"prior_cx_b\", \"Control beta\", value = 1, min = 0, step = 0.5),\n            numericInput(\"prior_tx_a\", \"Treated alpha\", value = 1, min = 0, step = 0.5),\n            numericInput(\"prior_tx_b\", \"Treated beta\", value = 1, min = 0, step = 0.5)\n          ),\n          card(\n            card_header(\"Safety Database\"),\n            numericInput(\"ped_cx_n\", \"Control N\", value = 0, min = 0),\n            numericInput(\"ped_cx_event\", \"Control Events\", value = 0, min = 0),\n            numericInput(\"ped_tx_n\", \"Treated N\", value = 0, min = 0),\n            numericInput(\"ped_tx_event\", \"Treated Events\", value = 0, min = 0)\n          ),\n          card(\n            card_header(\"New Study\"),\n            numericInput(\"new_n\", \"Sample Size\", value = 40, min = 0),\n            shinyWidgets::numericRangeInput(\"rand\", \"Randomization\", separator = \":\", value = c(1, 1)),\n            numericInput(\"fold_increase\", \"Fold increase over reference difference\", value = 2, min = 1)\n          )\n        )\n      ),\n      card(\n        layout_columns(\n          plotOutput(\"curve\"),\n          tableOutput(\"table\"),\n          col_widths = c(6, 6)\n        )\n      ),\n      col_widths = c(12, 12)\n    )\n  )\n)\n\nserver <- function(input, output) {\n\n  # Constrain inputs dynamically\n  observeEvent(input$ped_cx_n, {\n    updateSliderInput(inputId = \"ped_cx_event\", max = input$ped_cx_n)\n  })\n  observeEvent(input$ped_tx_n, {\n    updateSliderInput(inputId = \"ped_tx_event\", max = input$ped_tx_n)\n  })\n\n  prob_table <- reactive({\n    prob_rule_out2(\n      ref_tx = input$ref_tx,\n      ref_cx = input$ref_cx,\n      fold_increase = input$fold_increase,\n      prior_tx_a = input$prior_tx_a,\n      prior_tx_b = input$prior_tx_b,\n      prior_cx_a = input$prior_cx_a,\n      prior_cx_b = input$prior_cx_b,\n      ped_cx_event = input$ped_cx_event,\n      ped_cx_n = input$ped_cx_n,\n      ped_tx_event = input$ped_tx_event,\n      ped_tx_n = input$ped_tx_n,\n      new_n = input$new_n,\n      rand = input$rand\n    )\n  })\n\n  output$table <- renderTable({\n    prob_table()\n  }, digits = 4)\n\n  output$curve <- renderPlot({\n    df <- prob_table()\n\n    # plot(\n    #   x = df$N_t + df$N_c,\n    #   y = df$Probability,\n    #   type = \"n\",\n    #   ylim = c(0, 1),\n    #   xlab = \"Study Size\",\n    #   ylab = \"Probability\"\n    # )\n    #\n    # idf <- split(df, df$`Incidence Difference Factor`)\n    # for (i in seq_along(idf)) {\n    #\n    #   print(points(\n    #     x = idf[i]$N_t + idf[i]$N_c,\n    #     y = idf[i]$Probability,\n    #     type = \"b\"\n    #   ))\n    # }\n\n    tinyplot(\n      x = df$N_t + df$N_c,\n      y = df$Probability,\n      by = df$`Incidence Difference Factor`,\n      type = \"b\",\n      ylim = c(0, 1),\n      xlab = \"Study Size\",\n      ylab = \"Probability\"\n    )\n  })\n\n}\n\nshinyApp(ui = ui, server = server)\n","type":"text"},{"name":"calculator.R","content":"\nprob_rule_out2 <- function(\n    ref_tx = 0.06,\n    ref_cx = 0.03,\n    fold_increase = 3,\n    prior_tx_a = 1,\n    prior_tx_b = 1,\n    prior_cx_a = 1,\n    prior_cx_b = 1,\n    ped_cx_event = 0,\n    ped_cx_n = 0,\n    ped_tx_event = 0,\n    ped_tx_n = 0,\n    new_n = 40,\n    rand = c(1, 1)\n) {\n  num_outputs <- 6\n  m <- fold_increase # for length of interval of treatment responses\n\n  new_n <- seq(round(new_n / 2), round(new_n * 2), length = num_outputs)\n\n  trt_nseq <- round(new_n * rand[1] / sum(rand))\n  pbo_nseq <- new_n - trt_nseq\n  pbo_pcseq_low <- ref_cx # kept at 0.03 for common ADR; usually 0.02 to 0.05\n  trt_pcseq_low <- ref_tx\n  trt_pcseq <- seq(trt_pcseq_low, pbo_pcseq_low + m * (trt_pcseq_low - pbo_pcseq_low), length = num_outputs)\n  pbo_pcseq <- pbo_pcseq_low #rep(pbo_pcseq_low, length(trt_pcseq))\n  delta_p <- trt_pcseq - pbo_pcseq\n  delta_p_low <- trt_pcseq_low - pbo_pcseq_low\n  delta_pmult <- delta_p / delta_p_low\n  # browser()\n\n\n  alpha1 <- prior_tx_a + ped_tx_event\n  beta1 <- prior_tx_b + (ped_tx_n - ped_tx_event)\n  alpha2 <- prior_cx_a + ped_cx_event\n  beta2 <- prior_cx_b + (ped_cx_n - ped_cx_event)\n\n  inputs_0 <- data.frame(\n    trt_nseq = trt_nseq,\n    pbo_nseq = pbo_nseq\n  )\n  inputs_1 <- data.frame(\n    trt_pcseq = trt_pcseq,\n    alpha1 = alpha1,\n    beta1 = beta1,\n    pbo_pcseq = pbo_pcseq,\n    alpha2 = alpha2,\n    beta2 = beta2,\n    delta_p = delta_p,\n    delta_pmult = delta_pmult\n  )\n\n  inputs <- cbind(\n    inputs_0[rep(seq_len(num_outputs), each = num_outputs), ],\n    inputs_1[rep(seq_len(num_outputs), times = num_outputs), ]\n  )\n\n  # MatrixA <- matrix(nrow = nrow(inputs), ncol = 3)\n\n  MatrixA <- .mapply(\n    dots = as.list(inputs),\n    MoreArgs = list(),\n    FUN = function(trt_nseq,\n                   trt_pcseq,\n                   alpha1,\n                   beta1,\n                   pbo_nseq,\n                   pbo_pcseq,\n                   alpha2,\n                   beta2,\n                   delta_p,\n                   delta_pmult) {\n      a1 <- trt_nseq * trt_pcseq + alpha1\n      b1 <- trt_nseq - trt_nseq * trt_pcseq + beta1\n      a2 <- pbo_nseq * pbo_pcseq + alpha2\n      b2 <- pbo_nseq - pbo_nseq * pbo_pcseq + beta2\n      x <- seq(delta_p, 1, 0.001) # interval for integration\n      y <- sapply(x, diff_beta_plus, a1 = a1, a2 = a2, b1 = b1, b2 = b2)\n      xy <- cbind(x, y)\n      xy.narm <- xy[complete.cases(xy), ]\n      Pr.less.x <- 1 - pracma::trapz(xy.narm[, 1], xy.narm[, 2])\n      c(delta_p, delta_pmult, Pr.less.x)\n    })\n\n  # for (j in seq_len(num_ouputs)) {\n  #   a1 <- trt_nseq * trt_pcseq[j] + alpha1\n  #   b1 <- trt_nseq - trt_nseq * trt_pcseq[j] + beta1\n  #   a2 <- pbo_nseq * pbo_pcseq[j] + alpha2\n  #   b2 <- pbo_nseq - pbo_nseq * pbo_pcseq[j] + beta2\n  #   x <- seq(delta_p[j], 1, 0.001) # interval for integration\n  #   y <- sapply(x, diff_beta_plus, a1 = a1, a2 = a2, b1 = b1, b2 = b2)\n  #   xy <- cbind(x, y)\n  #   xy.narm <- xy[complete.cases(xy), ]\n  #   Pr.less.x <- 1 - pracma::trapz(xy.narm[, 1], xy.narm[, 2])\n  #   MatrixA[j, ] <- c(delta_p[j], delta_pmult[j], Pr.less.x)\n  # }\n\n\n  Safety.mat <- data.frame(t(simplify2array(MatrixA)), N_t = inputs$trt_nseq, N_c = inputs$pbo_nseq)\n  colnames(Safety.mat) <- c(\"Incidence Difference\", \"Incidence Difference Factor\", \"Probability\", \"N_t\", \"N_c\")\n  return(Safety.mat)\n}\n\ndiff_beta_plus <- function(a1, a2, b1, b2, x) {\n  A <- beta(a1, b1) * beta(a2, b2)\n  p1.density <- try(beta(a2, b1) * x^(b1 + b2 - 1) * (1 - x)^(a2 + b1 - 1) * F1(b1, a1 + a2 + b1 + b2 - 2, 1 - a1, b1 + a2, 1 - x, 1 - x^2) / A)\n  if (class(p1.density) != \"try-error\") {\n    p1.density\n  } else {\n    p1.density <- \"NA\"\n  }\n}\n\ndiff_beta_plus_log <- function(a1, a2, b1, b2, x) {\n  logA <- lbeta(a1, b1) + lbeta(a2, b2)\n  lbeta(a2, b1) +\n    (b1 + b2 - 1) * log(x) +\n    (a2 + b1 - 1) * log(1 - x) +\n    log(F1(b1, a1 + a2 + b1 + b2 - 2, 1 - a1, b1 + a2, 1 - x, 1 - x^2)) -\n    logA\n}\n\nF1 <- function(a, b, b.prime, c, x, y, ...) {\n  A1.f1 <- try({\n    integrate(\n      f = A1.simple,\n      lower = 0,\n      upper = 1,\n      a = a,\n      b = b,\n      b.prime = b.prime,\n      c = c,\n      x = x,\n      y = y,\n      subdivisions = 5000,\n      rel.tol = .Machine$double.eps^0.5,\n      stop.on.error = FALSE, ...)$value\n  },\n  silent = TRUE\n  )\n  if (class(A1.f1) != \"try-error\") {\n    A1.f2 <- gamma(c) / (gamma(a) * gamma(c - a)) * A1.f1\n  } else {\n    A1.f2 <- NA\n  }\n}\n\n\nA1.simple <- function(u, a, b, b.prime, c, x, y) {\n  u^(a - 1) * (1 - u)^(c - a - 1) * (1 - u * x)^(-b) * (1 - u * y)^(-b.prime)\n}\n","type":"text"}]
